<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Commands for Real-World Scenarios</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>üßë‚Äçüíª Git Commands for Real-World Scenarios</h1>
            <p class="subtitle">Production-ready Git workflows for engineering teams</p>
        </header>

        <div class="interactive-tools">
            <button class="tool-button" onclick="openSimulator()">
                <span class="tool-icon">üéÆ</span>
                <span class="tool-title">Command Simulator</span>
                <span class="tool-desc">Practice Git commands in a safe sandbox</span>
            </button>
            <button class="tool-button" onclick="openDecisionTree()">
                <span class="tool-icon">üå≥</span>
                <span class="tool-title">Decision Tree</span>
                <span class="tool-desc">Find the right command for your situation</span>
            </button>
        </div>

        <div class="search-container">
            <input type="text" class="search-input" id="searchInput" placeholder="Search scenarios... (e.g., 'merge conflict', 'undo commit', 'branch')">
        </div>

        <div class="guide-content">
<h2>I. The Absolute Fundamentals (Zero)</h2>
<p><em>These are the commands you'll use 90% of the time.</em></p>
<table class="table">
  <thead>
    <tr>
      <th>Command</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>git init</code></td>
      <td>Initialize a new Git repo in the current folder.</td>
      <td><code>git init</code></td>
    </tr>
    <tr>
      <td><code>git clone &lt;url&gt;</code></td>
      <td>Download a remote repository to your machine.</td>
      <td><code>git clone https://github.com/user/repo.git</code></td>
    </tr>
    <tr>
      <td><code>git status</code></td>
      <td><strong>Your best friend.</strong> Shows the state of your working directory and staging area.</td>
      <td><code>git status</code></td>
    </tr>
    <tr>
      <td><code>git add &lt;file&gt;</code></td>
      <td>Stage a specific file for the next commit.</td>
      <td><code>git add index.html</code></td>
    </tr>
    <tr>
      <td><code>git add .</code></td>
      <td>Stage <strong>all</strong> new and modified files for the next commit.</td>
      <td><code>git add .</code></td>
    </tr>
    <tr>
      <td><code>git commit -m "msg"</code></td>
      <td>Take a snapshot of the staged changes with a descriptive message.</td>
      <td><code>git commit -m "Add login button"</code></td>
    </tr>
    <tr>
      <td><code>git push origin &lt;branch&gt;</code></td>
      <td>Upload your local commits to a remote repository (like GitHub).</td>
      <td><code>git push origin main</code></td>
    </tr>
    <tr>
      <td><code>git pull origin &lt;branch&gt;</code></td>
      <td>Download changes from the remote and merge them into your current branch.</td>
      <td><code>git pull origin main</code></td>
    </tr>
  </tbody>
</table>

<h2>II. Branching & Context Switching (Novice)</h2>
<p><em>Working on multiple features without messing up the main code.</em></p>
<table class="table">
  <thead>
    <tr>
      <th>Command</th>
      <th>Description</th>
      <th>Example</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>git branch</code></td>
      <td>List all local branches. The <code>*</code> shows your current branch.</td>
      <td><code>git branch</code></td>
    </tr>
    <tr>
      <td><code>git branch &lt;name&gt;</code></td>
      <td>Create a new branch based on your current commit.</td>
      <td><code>git branch new-feature</code></td>
    </tr>
    <tr>
      <td><code>git checkout &lt;branch&gt;</code></td>
      <td>Switch to an existing branch.</td>
      <td><code>git checkout new-feature</code></td>
    </tr>
    <tr>
      <td><code>git checkout -b &lt;name&gt;</code></td>
      <td><strong>Create a new branch and switch to it immediately.</strong> (Very common)</td>
      <td><code>git checkout -b fix-bug</code></td>
    </tr>
    <tr>
      <td><code>git switch &lt;branch&gt;</code></td>
      <td>Newer, clearer way to switch branches (Git 2.23+).</td>
      <td><code>git switch main</code></td>
    </tr>
    <tr>
      <td><code>git switch -c &lt;name&gt;</code></td>
      <td>Newer way to create and switch to a branch.</td>
      <td><code>git switch -c new-feature</code></td>
    </tr>
    <tr>
      <td><code>git merge &lt;branch&gt;</code></td>
      <td>Combine the specified branch's history into your current branch.</td>
      <td><code>git switch main</code> <br> <code>git merge new-feature</code></td>
    </tr>
    <tr>
      <td><code>git branch -d &lt;branch&gt;</code></td>
      <td>Delete a branch that has been merged (safe delete).</td>
      <td><code>git branch -d old-feature</code></td>
    </tr>
    <tr>
      <td><code>git branch -D &lt;branch&gt;</code></td>
      <td><strong>Force delete a branch,</strong> even if it hasn't been merged. (Be careful!)</td>
      <td><code>git branch -D abandoned-experiment</code></td>
    </tr>
  </tbody>
</table>

<h2>III. Undoing Mistakes & Rewriting History (Apprentice)</h2>
<p><em>The "oh crap" moments. Use these carefully.</em></p>
<table class="table">
  <thead>
    <tr>
      <th>Command</th>
      <th>Description</th>
      <th>When to Use</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>git restore &lt;file&gt;</code></td>
      <td>Discard changes in your working directory for a specific file.</td>
      <td>"I haven't <code>add</code>ed this file yet and I want to start over."</td>
    </tr>
    <tr>
      <td><code>git restore --staged &lt;file&gt;</code></td>
      <td>Unstage a file <strong>without</strong> losing the changes in your working directory.</td>
      <td>"I <code>add</code>ed the wrong file by accident."</td>
    </tr>
    <tr>
      <td><code>git commit --amend</code></td>
      <td><strong>Edit the most recent commit.</strong> Change the message or add forgotten files.</td>
      <td>"I just committed but forgot a file!" or "My commit message has a typo."</td>
    </tr>
    <tr>
      <td><code>git reset --soft HEAD~1</code></td>
      <td>Undo the last commit but <strong>keep all your changes as staged</strong>.</td>
      <td>"I want to combine my last two commits."</td>
    </tr>
    <tr>
      <td><code>git reset --hard HEAD~1</code></td>
      <td><strong>Completely obliterate</strong> the last commit and all its changes. <strong>Warning: Unrecoverable.</strong></td>
      <td>"That last commit was a huge mistake, I want to pretend it never happened."</td>
    </tr>
    <tr>
      <td><code>git revert &lt;commit-hash&gt;</code></td>
      <td>Create a <em>new commit</em> that undoes the changes of a previous commit. <strong>Safe for public history.</strong></td>
      <td>"I need to undo a commit I already pushed to others."</td>
    </tr>
  </tbody>
</table>

<h2>IV. Advanced History Manipulation (Hero)</h2>
<p><em>For a clean, professional commit history.</em></p>
<table class="table">
  <thead>
    <tr>
      <th>Command</th>
      <th>Description</th>
      <th>Use Case</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>git rebase &lt;branch&gt;</code></td>
      <td>Replay your current branch's commits on top of the latest version of <code>&lt;branch&gt;</code>.</td>
      <td>"I want a clean, linear history for my feature branch before merging."</td>
    </tr>
    <tr>
      <td><code>git rebase -i HEAD~3</code></td>
      <td><strong>Interactive Rebase.</strong> Opens an editor to squash, edit, reorder, or drop commits.</td>
      <td>"I have 5 messy 'WIP' commits I want to combine into one clean commit."</td>
    </tr>
    <tr>
      <td><code>git cherry-pick &lt;commit&gt;</code></td>
      <td>Apply the changes from a specific commit to your current branch.</td>
      <td>"I need just that one bugfix from another branch, not the whole thing."</td>
    </tr>
    <tr>
      <td><code>git stash</code></td>
      <td>Temporarily shelves (stashes) all your uncommitted changes.</td>
      <td>"My boss needs a fix NOW, but I'm in the middle of something."</td>
    </tr>
    <tr>
      <td><code>git stash pop</code></td>
      <td>Re-apply your most recently stashed changes and remove them from the stash.</td>
      <td>"Okay, boss's fix is done, back to my feature."</td>
    </tr>
  </tbody>
</table>

<h2>V. Inspecting & Comparing (Detective)</h2>
<p><em>Figuring out what happened and when.</em></p>
<table class="table">
  <thead>
    <tr>
      <th>Command</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>git log</code></td>
      <td>Show the commit history.</td>
    </tr>
    <tr>
      <td><code>git log --oneline --graph --all</code></td>
      <td>Fancy, compact history view with branch topology. <strong>Memorize this.</strong></td>
    </tr>
    <tr>
      <td><code>git diff</code></td>
      <td>Show unstaged changes since the last commit.</td>
    </tr>
    <tr>
      <td><code>git diff --staged</code></td>
      <td>Show staged changes (what you've <code>add</code>ed).</td>
    </tr>
    <tr>
      <td><code>git blame &lt;file&gt;</code></td>
      <td>Show who last modified each line of a file and in which commit.</td>
    </tr>
  </tbody>
</table>

<h2>VI. Synchronizing with a Remote (Collaborator)</h2>
<p><em>Working with others on GitHub/GitLab.</em></p>
<table class="table">
  <thead>
    <tr>
      <th>Command</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>git fetch origin</code></td>
      <td>Download all changes from the remote <strong>without</strong> merging them. "See what others have done."</td>
    </tr>
    <tr>
      <td><code>git pull --rebase origin main</code></td>
      <td><strong>Best practice pull.</strong> Fetches remote changes and rebases your commits on top of them. Cleaner than a merge.</td>
    </tr>
    <tr>
      <td><code>git push origin --delete &lt;branch&gt;</code></td>
      <td>Delete a branch on the remote (e.g., after merging a Pull Request).</td>
    </tr>
    <tr>
      <td><code>git remote -v</code></td>
      <td>Show the URLs of your connected remote repositories.</td>
    </tr>
  </tbody>
</table>
<h3>Deleting a Remote Branch in Git</h3>
<p>Deleting a remote branch is a common task when you've merged a feature branch and want to clean up. Here's how to do it:</p>
<h4>The Command</h4>
<div class="code-block"><pre><code>git push origin --delete branch-name</code></pre></div>
<p>or the shorter equivalent:</p>
<div class="code-block"><pre><code>git push origin :branch-name</code></pre></div>
<h4>Step-by-Step Explanation</h4>
<ol>
  <li><strong>First, check what remote branches exist:</strong>
    <div class="code-block"><pre><code>git branch -r</code></pre></div>
  </li>
  <li><strong>Delete the remote branch:</strong>
    <div class="code-block"><pre><code># Example: delete a branch named "feature-login"
git push origin --delete feature-login</code></pre></div>
  </li>
  <li><strong>Verify it's gone:</strong>
    <div class="code-block"><pre><code>git branch -r  # Should no longer show the deleted branch</code></pre></div>
  </li>
</ol>
<h4>Important Notes</h4>
<ul>
  <li><strong>You can't delete the default branch</strong> (usually <code>main</code> or <code>master</code>) unless you change the default first</li>
  <li><strong>Other team members</strong> will need to run <code>git fetch --prune</code> to sync their local remote-tracking branches</li>
  <li><strong>Deleting a remote branch doesn't delete local branches</strong> - you'll need to do that separately</li>
</ul>
<h4>Example Workflow</h4>
<div class="code-block"><pre><code># List all remote branches
git branch -r

# Delete the remote feature-login branch
git push origin --delete feature-login

# Also delete the local branch if you're done with it
git branch -d feature-login

# Clean up remote-tracking references
git fetch --prune</code></pre></div>
<h4>What If You Get an Error?</h4>
<p>If you see an error like <code>remote ref does not exist</code>, it means:
<ol>
  <li>The branch was already deleted, or</li>
  <li>You typed the branch name incorrectly</li>
</ol>
<p>Always double-check with <code>git branch -r</code> first!</p>
</div>

    <!-- Command Simulator Modal -->
    <div id="simulatorModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('simulatorModal')">&times;</span>
            <h2>Git Command Simulator</h2>
            <p>Practice commands safely. Your real repository will not be affected.</p>
            <div class="simulator-ui">
                <div id="gitGraph" class="git-graph">Initialize a repository with 'git init' to begin...</div>
                <div id="commandOutput" class="command-output">Ready to execute Git commands...</div>
                <div class="command-input-wrapper">
                    <span class="prompt">$</span>
                    <input type="text" id="commandInput" placeholder="e.g., git commit -m 'My first commit'">
                    <button onclick="executeCommand()">Execute</button>
                </div>
            </div>
            <button onclick="resetSimulator()">Reset Simulator</button>
        </div>
    </div>

    <!-- Decision Tree Modal -->
    <div id="decisionTreeModal" class="modal">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal('decisionTreeModal')">&times;</span>
            <h2>Decision Tree Assistant</h2>
            <p>Find the right command by answering a few questions.</p>
            <div id="decisionTreeContainer">
                <!-- Decision tree will be rendered here by JS -->
            </div>
        </div>
    </div>

        <footer>
            <p>Built for production environments. Save this reference and never get stuck with Git again.</p>
        </footer>
    </div>

    <script>
        // Modal functionality
        function openSimulator() {
            document.getElementById('simulatorModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
        }

        function openDecisionTree() {
            document.getElementById('decisionTreeModal').style.display = 'block';
            document.body.style.overflow = 'hidden';
            resetDecisionTree();
        }

        function closeModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Close modal when clicking outside
        window.onclick = function(event) {
            const simulatorModal = document.getElementById('simulatorModal');
            const decisionModal = document.getElementById('decisionTreeModal');
            if (event.target === simulatorModal) {
                closeModal('simulatorModal');
            }
            if (event.target === decisionModal) {
                closeModal('decisionTreeModal');
            }
        }

        // Command Simulator Logic
        let gitState = {
            initialized: false,
            currentBranch: 'main',
            branches: [],
            commits: [],
            staged: [],
            unstaged: [],
            tags: {},
            remotes: {},
            reflog: []
        };

        function logRef(message) {
            const headCommit = gitState.commits[gitState.commits.length - 1];
            gitState.reflog.unshift(`HEAD@{${gitState.reflog.length}}: ${message}: ${headCommit ? headCommit.id.substring(0,7) : 'initial'} - ${gitState.currentBranch}`);
        }

        function executeCommand() {
            const input = document.getElementById('commandInput');
            const command = input.value.trim();
            const output = document.getElementById('commandOutput');

            if (!command) return;

            output.innerHTML += `\n<span class="prompt">$ ${input.value}</span>`;
            
            try {
                const result = processGitCommand(command);
                output.innerHTML += `\n${result}`;
                updateVisualization();
            } catch (error) {
                output.innerHTML += `\n<span class="error">‚ùå Error: ${error.message}</span>`;
            }

            output.scrollTop = output.scrollHeight;
            input.value = '';
        }

        function processGitCommand(command) {
            const parts = command.split(' ');
            const gitCmd = parts[0];

            if (gitCmd !== 'git') {
                throw new Error('Commands must start with "git"');
            }
            
            const subCmd = parts[1];

            if (!gitState.initialized && subCmd !== 'init') {
                throw new Error('Not a git repository. Please run "git init" first.');
            }

            switch (subCmd) {
                case 'init':
                    if (gitState.initialized) {
                        return 'Repository already initialized';
                    }
                    gitState.initialized = true;
                    gitState.currentBranch = 'main';
                    gitState.branches = ['main'];
                    gitState.commits = [{ id: 'abc1234', message: 'Initial commit', branch: 'main', author: 'Simulator', date: new Date().toUTCString() }];
                    logRef('commit (initial)');
                    return 'Initialized empty Git repository in /simulator/project';

                case 'checkout':
                    if (parts[2] === '-b' && parts[3]) {
                        const newBranch = parts[3];
                        if (gitState.branches.includes(newBranch)) {
                            throw new Error(`Branch '${newBranch}' already exists`);
                        }
                        gitState.branches.push(newBranch);
                        gitState.currentBranch = newBranch;
                        logRef(`checkout: moving from ${gitState.currentBranch} to ${newBranch}`);
                        return `Switched to a new branch '${newBranch}'`;
                    } else if (parts[2] && gitState.branches.includes(parts[2])) {
                        const fromBranch = gitState.currentBranch;
                        gitState.currentBranch = parts[2];
                        logRef(`checkout: moving from ${fromBranch} to ${gitState.currentBranch}`);
                        return `Switched to branch '${parts[2]}'`;
                    } else if (parts[2]) {
                        throw new Error(`Branch '${parts[2]}' does not exist`);
                    } else {
                        throw new Error('Invalid checkout command');
                    }

                case 'add':
                    if (parts[2] === '.') {
                        gitState.staged = ['file1.js', 'file2.css', 'README.md'];
                        return 'Added 3 files to staging area';
                    } else if (parts[2]) {
                        if (!gitState.staged.includes(parts[2])) {
                           gitState.staged.push(parts[2]);
                        }
                        return `Added ${parts[2]} to staging area`;
                    }
                    throw new Error('Specify a file to add or use "." for all files.');

                case 'commit':
                    if (gitState.staged.length === 0) {
                        return 'On branch ' + gitState.currentBranch + '\n' + 'nothing to commit, working tree clean';
                    }
                    const commitId = Math.random().toString(36).substr(2, 7);
                    const msgIndex = command.indexOf('-m');
                    const message = msgIndex !== -1 ? command.substring(msgIndex + 2).replace(/["\']/g, '').trim() : 'Commit message';
                    
                    gitState.commits.push({
                        id: commitId,
                        message,
                        branch: gitState.currentBranch,
                        author: 'Simulator',
                        date: new Date().toUTCString(),
                        parent: gitState.commits.filter(c => c.branch === gitState.currentBranch).pop()?.id || 'abc1234'
                    });
                    gitState.staged = [];
                    logRef('commit');
                    return `[${gitState.currentBranch} ${commitId}] ${message}`;

                case 'merge':
                    const mergeBranch = parts[2];
                    if (!mergeBranch || !gitState.branches.includes(mergeBranch)) {
                        throw new Error(`Branch '${mergeBranch}' does not exist`);
                    }
                    if (mergeBranch === gitState.currentBranch) {
                        throw new Error('Already on \\' + mergeBranch + '\'');
                    }
                    const mergeCommitId = Math.random().toString(36).substr(2, 7);
                    gitState.commits.push({
                        id: mergeCommitId,
                        message: `Merge branch '${mergeBranch}' into ${gitState.currentBranch}`,
                        branch: gitState.currentBranch,
                        author: 'Simulator',
                        date: new Date().toUTCString(),
                        type: 'merge'
                    });
                    logRef(`merge ${mergeBranch}`)
                    return `Merged branch '${mergeBranch}' into '${gitState.currentBranch}'`;

                case 'branch':
                    if ((parts[2] === '-d' || parts[2] === '-D') && parts[3]) {
                        const branchToDelete = parts[3];
                        if (branchToDelete === 'main') {
                            throw new Error('Cannot delete the main branch.');
                        }
                        const branchIndex = gitState.branches.indexOf(branchToDelete);
                        if (branchIndex === -1) {
                            throw new Error(`Branch '${branchToDelete}' not found.`);
                        }
                        gitState.branches.splice(branchIndex, 1);
                        if (gitState.currentBranch === branchToDelete) {
                            gitState.currentBranch = 'main';
                            return `Deleted branch ${branchToDelete} and switched to branch main.`;
                        }
                        return `Deleted branch ${branchToDelete}.`;
                    } else if (parts[2]) {
                        const newBranch = parts[2];
                        if (newBranch.startsWith('-')) {
                            throw new Error(`Invalid branch name '${newBranch}'. Branch names cannot start with a dash.`);
                        }
                        if (gitState.branches.includes(newBranch)) {
                            throw new Error(`Branch '${newBranch}' already exists`);
                        }
                        gitState.branches.push(newBranch);
                        return `Created branch '${newBranch}'`;
                    } else {
                        return gitState.branches.map(b => b === gitState.currentBranch ? `* ${b}` : `  ${b}`).join('\n');
                    }
                
                case 'reset':
                    const target = parts[2];
                    if (!target) throw new Error('Please specify a file to reset.');
                    const stagedIndex = gitState.staged.indexOf(target);
                    if (stagedIndex > -1) {
                        gitState.staged.splice(stagedIndex, 1);
                        return `Unstaged ${target}`;
                    }
                    return `File ${target} not staged.`;

                case 'rm':
                    const fileToRemove = parts[2];
                    if (!fileToRemove) throw new Error('Please specify a file to remove.');
                    // This is a simplified rm, it just unstages.
                    const stagedFileIndex = gitState.staged.indexOf(fileToRemove);
                    if (stagedFileIndex > -1) {
                        gitState.staged.splice(stagedFileIndex, 1);
                        return `rm '${fileToRemove}'`;
                    }
                    throw new Error(`File not found in staging area: ${fileToRemove}`);

                case 'remote':
                    if (parts[2] === 'add' && parts[3] && parts[4]) {
                        gitState.remotes[parts[3]] = parts[4];
                        return `Added remote '${parts[3]}'`;
                    }
                    if (parts[2] === '-v') {
                        let remoteOutput = '';
                        for (const name in gitState.remotes) {
                            remoteOutput += `${name}\t${gitState.remotes[name]} (fetch)\n`;
                            remoteOutput += `${name}\t${gitState.remotes[name]} (push)\n`;
                        }
                        return remoteOutput.trim() || 'No remotes configured.';
                    }
                    throw new Error('Unsupported remote command.');

                case 'fetch':
                    // Simplified fetch
                    return 'Simulating fetch... Remote branches are now up-to-date.';

                case 'tag':
                    const tagName = parts[2];
                    if (!tagName) {
                        return Object.keys(gitState.tags).join('\n') || 'No tags found.';
                    }
                    const head = gitState.commits[gitState.commits.length - 1];
                    gitState.tags[tagName] = head.id;
                    return `Created tag '${tagName}'`;

                case 'reflog':
                    return gitState.reflog.join('\n') || 'Reflog is empty.';

                case 'status':
                    let status = `On branch ${gitState.currentBranch}\n`;
                    if (gitState.staged.length > 0) {
                        status += 'Changes to be committed:\n';
                        gitState.staged.forEach(file => {
                            status += `  <span class="staged">(new file)  ${file}</span>\n`;
                        });
                    } else {
                        status += 'nothing to commit, working tree clean';
                    }
                    return status;

                case 'log':
                    const oneline = parts.includes('--oneline');
                    let logOutput = '';
                    const reversedCommits = [...gitState.commits].reverse();
                    reversedCommits.forEach(commit => {
                        if (oneline) {
                            logOutput += `<span class="commit-id">${commit.id}</span> (${commit.branch}) ${commit.message}\n`;
                        } else {
                            logOutput += `commit <span class="commit-id">${commit.id}</span>\n`;
                            logOutput += `Author: ${commit.author}\n`;
                            logOutput += `Date:   ${commit.date}\n\n`;
                            logOutput += `    ${commit.message}\n\n`;
                        }
                    });
                    return logOutput.trim();

                case 'show':
                    const commitToShow = parts[2];
                    if (!commitToShow) {
                        throw new Error('Please specify a commit hash to show.');
                    }
                    const foundCommit = gitState.commits.find(c => c.id.startsWith(commitToShow));
                    if (!foundCommit) {
                        throw new Error(`Commit '${commitToShow}' not found.`);
                    }
                    let showOutput = `commit <span class="commit-id">${foundCommit.id}</span>\n`;
                    showOutput += `Author: ${foundCommit.author}\n`;
                    showOutput += `Date:   ${foundCommit.date}\n\n`;
                    showOutput += `    ${foundCommit.message}\n\n`;
                    showOutput += `diff --git a/file1.js b/file1.js\n<span class="staged">--- a/file1.js\n+++ b/file1.js\n@@ -0,0 +1 @@\n+console.log("hello world");</span>\n`;
                    return showOutput;

                default:
                    const availableCmds = ['init', 'add', 'commit', 'branch', 'checkout', 'status', 'merge', 'log', 'show', 'remote', 'fetch', 'tag', 'reflog', 'reset', 'rm'].join(', ');
                    throw new Error(`'${subCmd}' is not a recognized command. Available commands: ${availableCmds}`);
            }
        }

        function updateVisualization() {
            const graph = document.getElementById('gitGraph');
            
            if (!gitState.initialized) {
                graph.innerHTML = '<span class="placeholder">Initialize a repository with \'git init\' to begin...</span>';
                return;
            }

            let viz = `<strong>Branches:</strong>\n`;
            gitState.branches.forEach(branch => {
                const indicator = branch === gitState.currentBranch ? '* ' : '  ';
                viz += `<span class="branch ${branch === gitState.currentBranch ? 'active' : ''}">${indicator}${branch}</span>\n`;
            });

            viz += '\n<strong>Commit History (main):</strong>\n';
            const mainCommits = gitState.commits.filter(c => c.branch === 'main').slice(-4).reverse();
            mainCommits.forEach((commit, index) => {
                viz += `‚óè <span class="commit-id">${commit.id}</span> - ${commit.message}\n`;
                if (index < mainCommits.length - 1) viz += '‚îÇ\n';
            });
            
            const otherBranches = gitState.branches.filter(b => b !== 'main');
            otherBranches.forEach(branch => {
                const branchCommits = gitState.commits.filter(c => c.branch === branch).slice(-2).reverse();
                if (branchCommits.length > 0) {
                    viz += `\n<strong>History (${branch}):</strong>\n`;
                    branchCommits.forEach((commit, index) => {
                         viz += `‚óè <span class="commit-id">${commit.id}</span> - ${commit.message}\n`;
                         if (index < branchCommits.length - 1) viz += '‚îÇ\n';
                    });
                }
            });

            if (Object.keys(gitState.tags).length > 0) {
                viz += '\n<strong>Tags:</strong>\n';
                for (const tagName in gitState.tags) {
                    viz += `üè∑Ô∏è ${tagName} -> ${gitState.tags[tagName].substring(0,7)}\n`;
                }
            }


            graph.innerHTML = viz;
        }

        function resetSimulator() {
            gitState = {
                initialized: false,
                currentBranch: 'main',
                branches: [],
                commits: [],
                staged: [],
                unstaged: [],
                tags: {},
                remotes: {},
                reflog: []
            };
            document.getElementById('commandOutput').innerHTML = 'Repository reset. Ready to execute Git commands...';
            updateVisualization();
            document.getElementById('gitGraph').innerHTML = '<span class="placeholder">Initialize a repository with \'git init\' to begin...</span>';
        }

        // Decision Tree Logic
        const decisionTree = {
            'start': {
                question: 'What do you need help with?',
                options: {
                    'undo': {
                        title: 'Undo something',
                        question: 'What do you want to undo?',
                        options: {
                            'last-commit': {
                                title: 'Last Commit',
                                result: {
                                    title: 'Undo Last Commit',
                                    commands: [
                                        'git reset --soft HEAD~1  # Keep changes staged',
                                        'git reset HEAD~1         # Keep changes unstaged',
                                        'git reset --hard HEAD~1  # Discard changes (DANGEROUS)'
                                    ],
                                    explanation: 'Use --soft to keep changes, --hard to completely remove them.'
                                }
                            },
                            'staging': {
                                title: 'Staged Changes',
                                result: {
                                    title: 'Unstage Files',
                                    commands: [
                                        'git reset HEAD filename    # Unstage specific file',
                                        'git reset HEAD .          # Unstage all files'
                                    ],
                                    explanation: 'Removes files from staging area but keeps changes in working directory.'
                                }
                            }
                        }
                    },
                    'collaborate': {
                        title: 'Collaborate with others',
                        question: 'What collaboration task?',
                        options: {
                            'pull-request': {
                                title: 'Create Pull Request',
                                result: {
                                    title: 'Pull Request Workflow',
                                    commands: [
                                        'git checkout -b feature/my-feature',
                                        'git add . && git commit -m "feat: add new feature"',
                                        'git push -u origin feature/my-feature',
                                        '# Create PR in GitHub/GitLab interface'
                                    ],
                                    explanation: 'Follow feature branch workflow for collaborative development.'
                                }
                            },
                            'merge-conflict': {
                                title: 'Resolve Merge Conflict',
                                result: {
                                    title: 'Merge Conflict Resolution',
                                    commands: [
                                        'git status                  # See conflicted files',
                                        '# Edit files to resolve conflicts',
                                        'git add <resolved-file>',
                                        'git commit',
                                        'git merge --abort          # If you want to cancel'
                                    ],
                                    explanation: 'Look for <<<<<<< ======= >>>>>>> markers in conflicted files.'
                                }
                            }
                        }
                    },
                    'emergency': {
                        title: 'Fix an emergency',
                        question: 'What\'s the emergency?',
                        options: {
                            'pushed-secrets': {
                                title: 'Pushed Secrets/Passwords',
                                result: {
                                    title: 'üö® CRITICAL: Secrets in Repository',
                                    commands: [
                                        '# STEP 1: IMMEDIATELY rotate all exposed secrets!',
                                        'git filter-repo --path config/secrets.json --invert-paths',
                                        'git push --force-with-lease origin main',
                                        '# STEP 2: Everyone must re-clone the repository'
                                    ],
                                    explanation: 'Rotate secrets FIRST, then clean Git history. Coordinate with your team before force pushing.'
                                }
                            },
                            'lost-commits': {
                                title: 'Lost Important Commits',
                                result: {
                                    title: 'Recover Lost Commits',
                                    commands: [
                                        'git reflog --all           # Find lost commits',
                                        'git checkout <commit-hash> # Restore specific commit',
                                        'git checkout -b recovery-branch',
                                        'git cherry-pick <commit-hash>'
                                    ],
                                    explanation: 'Git rarely loses data permanently. Check reflog for recent activity.'
                                }
                            }
                        }
                    }
                }
            }
        };

        function resetDecisionTree() {
            renderDecisionStep(decisionTree['start']);
        }

        function renderDecisionStep(step) {
            const container = document.getElementById('decisionTreeContainer');
            container.innerHTML = ''; // Clear previous content

            if (!step) {
                container.innerHTML = '<p class="error">Something went wrong. Please reset.</p>';
                const resetButton = document.createElement('button');
                resetButton.textContent = 'Start Over';
                resetButton.onclick = resetDecisionTree;
                container.appendChild(resetButton);
                return;
            }

            const title = document.createElement('h3');
            title.textContent = step.question || step.title;
            container.appendChild(title);

            if (step.options) {
                const optionsList = document.createElement('div');
                optionsList.className = 'decision-options';
                for (const key in step.options) {
                    const option = step.options[key];
                    const button = document.createElement('button');
                    button.textContent = option.title;
                    button.onclick = () => renderDecisionStep(option);
                    optionsList.appendChild(button);
                }
                container.appendChild(optionsList);
            } else if (step.result) {
                const resultDiv = document.createElement('div');
                resultDiv.className = 'decision-result';
                
                const resultTitle = document.createElement('h4');
                resultTitle.textContent = step.result.title;
                resultDiv.appendChild(resultTitle);

                const explanation = document.createElement('p');
                explanation.textContent = step.result.explanation;
                resultDiv.appendChild(explanation);

                const codeBlock = document.createElement('div');
                codeBlock.className = 'code-block';
                const pre = document.createElement('pre');
                pre.textContent = step.result.commands.join('\n');
                codeBlock.appendChild(pre);
                resultDiv.appendChild(codeBlock);

                container.appendChild(resultDiv);
            }
            
            const resetButton = document.createElement('button');
            resetButton.textContent = 'Start Over';
            resetButton.onclick = resetDecisionTree;
            container.appendChild(resetButton);
        }

        function showTab(evt, tabName) {
            // Hide all tab contents
            const tabContents = document.querySelectorAll('.tab-content');
            tabContents.forEach(content => {
                content.classList.remove('active');
            });

            // Remove active class from all tabs
            const tabs = document.querySelectorAll('.nav-tab');
            tabs.forEach(tab => {
                tab.classList.remove('active');
            });

            // Show selected tab content
            document.getElementById(tabName).classList.add('active');

            // Add active class to clicked tab
            if (evt) {
                evt.currentTarget.classList.add('active');
            } else {
                // Fallback for initial load
                document.querySelector(`.nav-tab[onclick*="'${tabName}'"]`).classList.add('active');
            }
        }

        function copyCode(button) {
            const codeBlock = button.nextElementSibling;
            const code = codeBlock.textContent;
            
            navigator.clipboard.writeText(code).then(() => {
                const originalText = button.textContent;
                button.textContent = 'Copied!';
                button.style.background = 'var(--success)';
                
                setTimeout(() => {
                    button.textContent = originalText;
                    button.style.background = 'var(--bg-tertiary)';
                }, 2000);
            });
        }

        // Add smooth scrolling for internal links
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize with first tab
            showTab(null, 'basics');

            // Add keypress listener for simulator
            const commandInput = document.getElementById('commandInput');
            if (commandInput) {
                commandInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        executeCommand();
                    }
                });
            }

            // Search functionality
            const searchInput = document.getElementById('searchInput');
            searchInput.addEventListener('keyup', function() {
                const filter = searchInput.value.toLowerCase();
                const cards = document.querySelectorAll('.scenario-card');
                cards.forEach(card => {
                    const title = card.querySelector('.scenario-title').textContent.toLowerCase();
                    const description = card.querySelector('.scenario-description')?.textContent.toLowerCase() || '';
                    const code = card.querySelector('pre')?.textContent.toLowerCase() || '';
                    if (title.includes(filter) || description.includes(filter) || code.includes(filter)) {
                        card.style.display = '';
                    } else {
                        card.style.display = 'none';
                    }
                });
            });
        });
    </script>
</body>
</html>